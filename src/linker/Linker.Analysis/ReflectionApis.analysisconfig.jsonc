[

  // System.Activator
  {
    // Activator.CreateInstance over Type
    // Type type must exist (otherwise we wouldn't get to the call), so the only remaining problem is that
    // we require a presense of the .ctor for CreateInstance to work - and so member trimming will not work correctly.
    "Type": "System.Activator",
    "Methods": [
      "CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])",
      "CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)",
      "CreateInstance(System.Type,System.Object[],System.Object[])",
      "CreateInstance(System.Type,System.Object[])",
      "CreateInstance(System.Type,System.Boolean)",
      "CreateInstance(System.Type)",
      "CreateInstance<T>()"
    ],
    "Aspect": "MemberTrim",
    "Warn": "CreateInstance over type requires the type's .ctor to be referenced",
    "Category": "CreateInstance"
  },
  {
    // Activator.CreateInstance over string assembly, string type
    // This is effectively load assembly, find type and create instance in a row.
    // Activator.CreateInstanceFrom loads assembly from a file.
    // So even assembly trimming might have issues.
    // TODO: CreateInstanceFrom is potentially dangerous for single-file as it loads from a file path
    "Type": "System.Activator",
    "Methods": [
      "CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])",
      "CreateInstance(System.String,System.String,System.Object[])",
      "CreateInstance(System.String,System.String)",
      "CreateInstanceFrom"
    ],
    "Aspect": "AssemblyTrim",
    "Warn": "CreateInstance over assembly and type name or CreateInstanceFrom, if the assembly name is specified make sure the assembly is referenced, otherwise make sure the type is referenced and its .ctor is referenced",
    "Category": "CreateInstance"
  },

  // System.AppDomain
  {
    "Type": "System.AppDomain",
    "Methods": [ "get_BaseDirectory" ],
    "Aspect": "SingleFile",
    "Warn": "The base directory may not contain the same set of files when running the app from a single-file bundle. For example most assemblies will not be on disk.",
    "Category": "SingleFileUnfriendly"
  },
  {
    // AppDomain.CreateInstance over string assembly, string type
    // This is effectively load assembly, find type and create instance in a row.
    // So even assembly trimming might have issues.
    "Type": "System.AppDomain",
    "Methods": [
      "CreateInstance",
      "CreateInstanceAndUnwrap"
    ],
    "Aspect": "AssemblyTrim",
    "Warn": "CreateInstance over assembly and type name, if the assembly name is specified make sure the assembly is referenced, otherwise make sure the type is referenced and its .ctor is referenced",
    "Category": "CreateInstance"
  },
  {
    // AppDomain.CreateInstanceFrom loads an assembly from the specified file path (first argument)
    // This creates potential issues even for assembly trimming scenarios as the loaded assembly may have dependency
    // on the trimmed assemblies.
    // TODO: This is also potentially dangerous for Single-File as we're loading assembly from a file path (Which may not exist in single-file)
    "Type": "System.AppDomain",
    "Methods": [
      "CreateInstanceFrom",
      "CreateInstanceFromAndUnwrap"
    ],
    "Aspect": "AssemblyTrim",
    "Warn": "CreateInstance over assembly and type name, if the assembly name is specified make sure the assembly is referenced, otherwise make sure the type is referenced and its .ctor is referenced",
    "Category": "CreateInstance"
  },
  {
    // AppDomain.ExecuteAssembly loads an assembly and then executes the Main in it. So it has requirements to even assembly trimming.
    // TODO: This is also potentially dangerous for Single-File as we're loading assembly from a file path (Which may not exist in single-file)
    "Type": "System.AppDomain",
    "Methods": [
      "ExecuteAssembly",
      "ExecuteAssemblyByName"
    ],
    "Aspect": "AssemblyTrim",
    "Warn": "ExecuteAssembly: make sure the assembly to be executed is referenced and visible to the linker and that the type and method of the entry point is referenced as well.",
    "Category": "KnownReflection"
  },
  {
    // Enumerates all assemblies in the AppDomain - when trimming, some may not be there
    "Type": "System.AppDomain",
    "Methods": [
      "GetAssemblies",
      "ReflectionOnlyGetAssemblies"
    ],
    "Aspect": "AssemblyTrim",
    "Warn": "The enumeration may return a smaller set of assemblies as some may be trimmed.",
    "Category": "ToInvestigate_EnumMetadata"
  },

  {
    // Basically the same as Assembly.Load - assembly loading
    "Type": "System.AppDomain",
    "Methods": [
      "Load"
    ],
    "Aspect": "AssemblyTrim",
    "Warn": "Loading assembly from in-memory byte array or from a file. The new assembly may have references to assemblies/types/methods which were trimmed.",
    "Category": "KnownReflection"
  },


  // System.Delegate
  {
    // Create a delegate over a method specified by its name on a type. This is basically equivalent to Type.GetMethod.
    // There are other overloads which take MethodInfo instead of method name. Those should be safe as the type and the method
    // must be available to get both the Type and MethodInfo instances. Also at that point the method should be safe to actually invoke:
    // CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)
    // CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)
    // CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)
    // CreateDelegate(System.Type,System.Reflection.MethodInfo)
    "Type": "System.Delegate",
    "Methods": [
      ".ctor",
      "CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)",
      "CreateDelegate(System.Type,System.Type,System.String,System.Boolean)",
      "CreateDelegate(System.Type,System.Type,System.String)",
      "CreateDelegate(System.Type,System.Object,System.String,System.Boolean)",
      "CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)",
      "CreateDelegate(System.Type,System.Object,System.String)"
    ],
    "Aspect": "MemberTrim",
    "Warn": "Delegate.CreateDelegate with a method name - effectively the same as Type.GetMethod",
    "Category": "KnownReflection"
  },


  // System.Type
  {
    // All these methods enumerate types, when type trimming some may not be present.
    "Type": "System.Type",
    "Methods": [
      "FindInterfaces",
      "GetInterfaces",
      "GetNestedTypes",
      "GetMembers" // GetMembers is marked as TypeTrim because it can return nested types
    ],
    "Aspect": "TypeTrim",
    "Warn": "Some interfaces may be trimmed if they're not used by the app, so the search may not include all possible candidate",
    "Category": "KnownReflection_EnumMetadata"
  },
  {
    // All these methods enumerate members on a type, when member trimming some may not be present.
    "Type": "System.Type",
    "Methods": [
      "FindMembers",
      "GetConstructors",
      "GetEvents",
      "GetFields",
      "GetMethods",
      "GetProperties",
      "GetInterfaceMap" // ??? This is questionable - does linker actually trim members of interfaces?
    ],
    "Aspect": "MemberTrim",
    "Warn": "Some members may have been trimmed, this method may no return the full list anymore",
    "Category": "KnownReflection_EnumMetadata"
  },

  {
    "Type": "System.Type",
    "Methods": [
      "GetConstructor",
      "GetEvent",
      "GetField",
      "GetMethod",
      "GetMethodImpl",
      "GetProperty",
      "GetPropertyImpl",
      "InvokeMember"
    ],
    "Aspect": "MemberTrim",
    "Warn": "The requested member may have been trimmed, please make sure that there's a reference to it",
    "Category": "KnownReflection"
  },

  {
    "Type": "System.Type",
    "Methods": [
      // GetType() is excluded as that is different, it returns the type of the current instance (it's basically object.GetType) and thus perfectly safe
      "GetType(System.String)",
      "GetType(System.String,System.Boolean)",
      "GetType(System.String,System.Boolean,System.Boolean)",
      "GetType(System.String,System.Func`2<System.Reflection.AssemblyName,System.Reflection.Assembly>,System.Func`4<System.Reflection.Assembly,System.String,System.Boolean,System.Type>)",
      "GetType(System.String,System.Func`2<System.Reflection.AssemblyName,System.Reflection.Assembly>,System.Func`4<System.Reflection.Assembly,System.String,System.Boolean,System.Type>,System.Boolean)",
      "GetType(System.String,System.Func`2<System.Reflection.AssemblyName,System.Reflection.Assembly>,System.Func`4<System.Reflection.Assembly,System.String,System.Boolean,System.Type>,System.Boolean,System.Boolean)",
      "ReflectionOnlyGetType",
      "GetInterface",
      "GetMember", // TypeTrim because it can return nested types
      "GetNestedType",
      "GetTypeFromCLSID", // TODO - validate this, but it's likely basically equivalent to ask for type by name
      "GetTypeFromProgID" // TODO - validate this, but it's likely basically equivalent to ask for type by name
    ],
    "Aspect": "TypeTrim",
    "Warn": "The requested type may have been trimmed, please make sure that there's a reference to it",
    "Category": "KnownReflection"
  },

  // GetTypeArray - safe since it is basically equivalent to object.GetType
  // GetTypeCode and GetTypeCodeImpl - safe as it doesn't introduce new dependency on anything

  // GetTypeFromHandle - safe. This is the call used when typeof(type) is used, and in this case the type is determined
  // by an ldtoken instruction. For that to exist the type must have a token and thus it must exist in the assembly.
  // Note that this does not put an additional requirements on the type (like ctors, methods and so on).

  {
    // TODOs - needs more investigation
    "Type": "System.Type",
    "Methods": [
      "MakeArrayType", // This one is probably safe, but need to double check
      "MakeGenericMethodParameter", // No idea what this does
      "MakeGenericSignatureType", // No idea what this does
      "MakeGenericType" // Probably safe on its own, but it can cause problems for the linker to determine generic instantiations if we decide to implement that
    ],
    "Aspect": "MemberTrim",
    "Warn": "TODO",
    "Category": "ToInvestigate_GenericInstantiation"
  },


  // System.Reflection.Assembly
  {
    "Type": "System.Reflection.Assembly",
    "Methods": [
      "get_CodeBase",
      "get_EscapedCodeBase",
      "get_Location"
    ],
    "Aspect": "SingleFile",
    "Warn": "This property returns a file path, which in single-file scenario may not be a valid path or could be empty/null",
    "Category": "SingleFileUnfriendly"
  },

  {
    "Type": "System.Reflection.Assembly",
    "Methods": [
      "get_CustomAttributes",
      "GetCustomAttributes",
      "IsDefined" // This is dangerous due to inheritance - one can ask IsDefined(BaseAttribute), but linker could trim all derived attributes
    ],
    "Aspect": "TypeTrim",
    "Warn": "If enabled the linker may trim attributes which are not refered to from code. This means that enumerating over attributes may return a trimmed list",
    "Category": "KeepUsedAttributeTypesOnlyUnsafe"
  },

  {
    "Type": "System.Reflection.Assembly",
    "Methods": [
      "get_DefinedTypes",
      "get_ExportedTypes",
      "get_Modules",
      "GetExportedTypes",
      "GetForwardedTypes",
      "GetLoadedModules",
      "GetModules",
      "GetReferencedAssemblies",
      "GetTypes"
    ],
    "Aspect": "TypeTrim",
    "Warn": "When trimmed the enumeration may return a subset of the original list.",
    "Category": "KnownReflection_EnumMetadata"
  },

  {
    "Type": "System.Reflection.Assembly",
    "Methods": [
      "get_EntryPoint", // Investigate if linker always keeps the entry point - otherwise potentially unsafe
      "GetFile", // Resource access - needs investigation
      "GetFiles", //    Investigate if linker actually removes resources
      "GetManifestResourceInfo",
      "GetManifestResourceNames",
      "GetManifestResourceStream",
      "GetModule", // Can linker actually trim modules from assemblies - potentially dangerous
      "GetSatelliteAssembly" // Can linker trim satellites?
    ],
    "Aspect": "MemberTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },

  {
    "Type": "System.Reflection.Assembly",
    "Methods": [ "CreateInstance" ],
    "Aspect": "TypeTrim",
    "Warn": "Make sure that the type is references and that its .ctor is also referenced",
    "Category": "CreateInstance"
  },

  {
    // Assembly.GetType
    // Adds a type to closure on existing assembly, so type trimming will not work correctly.
    // TODO: If the type is forwarded from the assembly in question it will also find it
    //   This could mean problems even for assembly trimming, if we rely on type tracking to figure out which assemblies to keep.
    "Type": "System.Reflection.Assembly",
    "Methods": [
      "GetType"
    ],
    "Aspect": "TypeTrim",
    "Warn": "GetType on a string, make sure that the type is referenced",
    "Category": "KnownReflection"
  },

  {
    // Assembly.Load
    // Load(string) and Load(AssemblyName) are effectively assembly references which the linker
    // doesn't see (as they are dynamic) - so they might need an assembly to be kept which linker could
    // otherwise trim. So for this reason they are dangerous.
    // It might be possible to recognize constants and handle those cases in the linker in the future.

    // Load(byte[]) and Load(byte[], byte[]) are effectively introducing new code into the app which the linker
    // didn't see. As such this code might have dependencies on things in the app which nothing else has dependencies on.
    // So linker might trim things this new code may need. For this reason usage of these APIs is dangerous.

    // LoadWithPartialName is basically just Load(string) - with a slightly different argument checks and error handling.
    // Loads new code from a file - similar to Load(byte[]) in its effect. It introduces new code into the app
    // which may have references to trimmed things - thus potentially breaking as linker can't analyze the code
    // added via these APIs.
    // TODO: LoadFile, LoadFrom and UnsafeLoadFrom are also potentially single-file dangerous
    "Type": "System.Reflection.Assembly",
    "Methods": [
      "Load",
      "LoadWithPartialName",
      "LoadFile",
      "LoadFrom",
      "UnsafeLoadFrom",
      "LoadModule", // Non implemented by .NET Core, but semantically same as Load
      "ReflectionOnlyLoad", // Not implemented but semantically unsafe
      "ReflectionOnlyLoadFrom" // Not implemented but semantically unsafe
    ],
    "Aspect": "AssemblyTrim",
    "Warn": "Make sure that linker sees the assemblies loaded like this",
    "Category": "KnownReflection"
  },

  // System.Reflection.Binder
  // The Binder itself is a purely abstract class so in itself is safe. Derived classes might not be though.

  // System.Reflection.ConstructorInfo
  // Since linker doesn't trim method bodies only: If there's a way to get to the ConstructorInfo
  // then the constructor must be present and exist as a fully functional method.
  // As such it must be callable as well. So even ConstructorInfo.Invoke is safe then.

  // System.Reflection.CustomAttributeData
  {
    "Type": "System.Reflection.CustomAttributeData",
    "Methods": [ "GetCustomAttributes" ],
    "Aspect": "TypeTrim",
    "Warn": "Linker may trim attributes",
    "Category": "KeepUsedAttributeTypesOnlyUnsafe"
  },
  // Otherwise the CustomAttributeData is safe, mainly because linker preserves entire attributes always.

  // System.Reflection.CustomAttributeExtensions
  // The way linker works with attributes is that:
  // It will keep attributes where the type of the attribute has been marked by usage elsewhere than the attribute usage itself.
  // This means that just adding the attribute to a method will not preserve the attribute. But asking for it explicitly by its type
  // will preserve the attribute.
  // The problem is that most of the attribute accessors in reflection APIs handle inheritance, so for example, I can ask for
  // attribute of type BaseAttribute and it will get me all attributes which derive from BaseAttribute.
  // This is not how linker works, linker will only perserve attributes which type is explicitly referenced. So in the above sample
  // in un-trimmed app I would get a BaseAttribute instance back (in reality some DerivedAttribute instance), but in trimmed app
  // I would not get anything back since the attribute would be trimmed.
  // If the linker is ran in this more aggresive mode, accessing pretty much any attribute through the reflection APIs is potentially
  // dangerous.
  {
    "Type": "System.Reflection.CustomAttributeExtensions",
    "Methods": [
      "GetCustomAttribute",
      "GetCustomAttributes",
      "IsDefined"
    ],
    "Aspect": "MemberTrim",
    "Warn": "Linker may trim attributes",
    "Category": "KeepUsedAttributeTypesOnlyUnsafe"
  },

  // System.Reflection.EventInfo
  {
    "Type": "System.Reflection.EventInfo",
    "Methods": [ "GetOtherMethods" ],
    "Aspect": "MemberTrim",
    "Warn": "Linker may trim methods",
    "Category": "KnownReflection_EnumMetadata"
  },
  // The other members of EventInfo are all safe
  // Linker always keeps add, remove and invoke methods on an event.

  // System.Reflection.ExceptionHandlingClause
  // Not dangerous as it doesn't introduce any new dependencies on its own (and one must have a MethodBody to get to it anyway)

  // System.Refleciton.FieldInfo
  {
    "Type": "System.Reflection.FieldInfo",
    // TODO: This is probably safe as the only way in IL to get a field handle is something like ldtoken
    // which the linker will recognize and mark the field accordingly.
    // May need additional investigation.
    "Methods": [
      // TODO: This is probably safe as the only way in IL to get a field handle is something like ldtoken
      // which the linker will recognize and mark the field accordingly.
      // May need additional investigation.
      "GetFieldFromHandle",

      // TODO: Don't know what exactly this does and if linker has any effect on it
      "GetOptionalCustomModifiers",
      "GetRequiredCustomModifiers"
    ],
    "Aspect": "MemberTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },
  // The other member are safe:
  // If the field exists (that is the app was able to get the FieldInfo instance)
  // then its value should be accessible.

  // System.Reflection.InterfaceMapping
  //  in itself it's not dangerous, getting to it might be and that should be marked.

  // System.Reflection.LocalVariableInfo
  //  only accessible through method body

  // System.Reflection.ManifestResourceInfo
  //  should be safe

  // System.Reflection.MemberInfo
  {
    // Typical problem with custom attributes and inheritance - see CustomAttributeExtensions for details
    "Type": "System.Reflection.MemberInfo",
    "Methods": [
      "get_CustomAttributes",
      "GetCustomAttributes",
      "GetCustomAttributesData",
      "IsDefined"
    ],
    "Aspect": "TypeTrim",
    "Warn": "Linker may remove attributes",
    "Category": "KeepUsedAttributeTypesOnlyUnsafe"
  },

  // System.Reflection.MethodBase
  {
    "Type": "System.Reflection.MethodBase",
    // TODO: This is probably safe as the only way in IL to get a method handle is something like ldtoken
    // which the linker will recognize and mark the method accordingly.
    // May need additional investigation.
    "Methods": [ "GetMethodFromHandle" ],
    "Aspect": "MemberTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },
  {
    "Type": "System.Reflection.MethodBase",
    // TODO: Linker doesn't trim method bodies, so if the app has access to MethodBase instance, then that method
    // will have its body present as well.
    // That said linker may rewrite the body of the method, so technically it is breaking.
    "Methods": [ "GetMethodBody" ],
    "Aspect": "MemberTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },

  // System.Reflection.MethodBody
  //   We guard the functionality of MethodBody via the access to it - which is MethodBase.GetMethodBody
  //   as such the functionality of this class alone is safe.

  // System.Reflection.MethodInfo
  {
    "Type": "System.Reflection.MethodInfo",
    "Methods": [ "get_ReturnTypeCustomAttributes" ],
    "Aspect": "TypeTrim",
    "Warn": "Liner may remove attributes",
    "Category": "KeepUsedAttributeTypesOnlyUnsafe"
  },
  {
    "Type": "System.Reflection.MethodInfo",
    "Methods": [
      // Probably safe on its own as all inputs are Type and thus must exist, but it may become problem if linker decides
      // to perform generic instantiation analysis.
      "MakeGenericMethod"
    ],
    "Aspect": "MemberTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },
  // CreateDelegate - it's actually safe. The method must exist (as MethodInfo exists) and the delegate type parameter must also exist
  //   so that there's value which is passed to the CreateDelegate. The added requirements are that the delegate type must inherit from
  //   MulticastDelegate (which is not a linker's concern, that will be validated at runtime) and that it has the compiler generated methods
  //   (like Invoke/BeginInvoke/EndInvoke). The latter is a linker's concern, but linker will keep all methods on delegate types always.
  // The other members should be safe as if the app has MethodInfo the method and its body must exist

  // System.Reflection.Module
  // This is very similar to Assembly, so lot of the same annotations here
  {
    "Type": "System.Reflection.Module",
    "Methods": [
      "FindTypes",
      "GetTypes"
    ],
    "Aspect": "TypeTrim",
    "Warn": "Linker may trim some types and thus return a subset",
    "Category": "KnownReflection_EnumMetadata"
  },
  {
    "Type": "System.Reflection.Module",
    "Methods": [
      "GetType"
    ],
    "Aspect": "TypeTrim",
    "Warn": "Make sure the type is referenced",
    "Category": "KnownReflection"
  },
  {
    "Type": "System.Reflection.Module",
    "Methods": [
      "get_CustomAttributes",
      "GetCustomAttributes",
      "GetCustomAttributesData",
      "IsDefined"
    ],
    "Aspect": "TypeTrim",
    "Warn": "Linker may trim attributes",
    "Category": "KeepUsedAttributeTypesOnlyUnsafe"
  },
  {
    "Type": "System.Reflection.Module",
    "Methods": [
      "GetField",
      "GetMethod",
      "GetMethodImpl"
    ],
    "Aspect": "MemberTrim",
    "Warn": "Make sure the member is referenced",
    "Category": "KnownReflection"
  },
  {
    "Type": "System.Reflection.Module",
    // In trimmed apps these may return different sets as compared to un-trimmed apps.
    // Unlike some of the other methods with similar behavior these are very likely to break apps
    // so marking them as dangerous for now.
    "Methods": [
      "GetFields",
      "GetMethods"
    ],
    "Aspect": "MemberTrim",
    "Warn": "Some members may be trimmed",
    "Category": "KnownReflection_EnumMetadata"
  },
  // GetModuleHandleImpl
  // GetObjectData
  // GetPEKind
  //   These should be safe
  {
    "Type": "System.Reflection.Module",
    // TODO - these can be potentially dangerous but it's unclear to which degree (aspect)
    //  what if the token is a reference to a different assembly?
    // Also - maybe this is safe since if the token exists, it must work
    // but then again if the token is trimmed this will fail.
    // Potentially dangerous - if the metadata token comes from unknown source, the result of this operation is effectively unknown
    // to the linker.
    "Methods": [
      "ResolveField",
      "ResolveMember",
      "ResolveMethod",
      "ResolveSignature",
      "ResolveString",
      "ResolveType"
    ],
    "Aspect": "TypeTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },

  // System.Reflection.ParameterInfo
  {
    "Type": "System.Reflection.ParameterInfo",
    "Methods": [
      "get_CustomAttributes",
      "GetCustomAttributes",
      "GetCustomAttributesData",
      "IsDefined"
    ],
    "Aspect": "TypeTrim",
    "Warn": "Linker may trim attributes",
    "Category": "KeepUsedAttributeTypesOnlyUnsafe"
  },
  {
    "Type": "System.Reflection.ParameterInfo",
    "Methods": [
      // TODO: don't know what this actually does and if linker has any effect on it
      "GetOptionalCustomModifiers",
      "GetRequiredCustomModifiers",
      // TODO: don't know what this is for
      "get_Member",
      // TODO: deserialization? ??
      "GetRealObject"
    ],
    "Aspect": "MemberTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },

  // System.Reflection.PropertyInfo
  {
    "Type": "System.Reflection.PropertyInfo",
    "Methods": [
      // These seem to be dangerous - linker seems to only keep get_/set_ methods if it sees direct reference to them
      // which would mean that accessing these through reflection only could break.
      "get_GetMethod",
      "GetAccessors",
      "GetGetMethod",
      "get_SetMethod",
      "GetSetMethod",
      "GetValue",
      "SetValue",
      // TODO: don't know what this actually does and if linker has any effect on it
      "GetOptionalCustomModifiers",
      "GetRequiredCustomModifiers",

      // TODO: This is weird since the implementation relies on GetGetMethod/GetSetMethod which are potentially dangerous (see above)
      "GetIndexParameters"
    ],
    "Aspect": "MemberTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },
  // GetConstantValue
  // GetRawConstantValue
  //    these should be safe

  // System.Reflection.ReflectionContext
  // TODO: No idea what this is for - could not find any use cases either
  {
    "Type": "System.Reflection.ReflectionContext",
    "Methods": [
      ".ctor"
    ],
    "Aspect": "MemberTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },

  // System.Reflection.ReflectionTypeLoadException
  {
    // Deserialization ??
    "Type": "System.Reflection.ReflectionTypeLoadException",
    "Methods": [ "GetObjectData" ],
    "Aspect": "MemberTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },


  // System.Reflection.TypeInfo
  {
    // All these methods enumerate types, when type trimming some may not be present.
    "Type": "System.Reflection.TypeInfo",
    "Methods": [
      "get_DeclaredNestedTypes",
      "get_ImplementedInterfaces",
      "get_DeclaredMembers" // Can return nested type
    ],
    "Aspect": "TypeTrim",
    "Warn": "Some interfaces may be trimmed if they're not used by the app, so the search may not include all possible candidate",
    "Category": "KnownReflection_EnumMetadata"
  },
  {
    // All these methods enumerate members on a type, when member trimming some may not be present.
    "Type": "System.Reflection.TypeInfo",
    "Methods": [
      "get_DeclaredConstructors",
      "get_DeclaredEvents",
      "get_DeclaredMethods",
      "GetDeclaredMethods",
      "get_DeclaredFields",
      "get_DeclaredProperties"
    ],
    "Aspect": "MemberTrim",
    "Warn": "Some members may have been trimmed, this method may no return the full list anymore",
    "Category": "KnownReflection_EnumMetadata"
  },

  {
    "Type": "System.Reflection.TypeInfo",
    "Methods": [
      "GetDeclaredEvent",
      "GetDeclaredField",
      "GetDeclaredMethod",
      "GetDeclaredProperty"
    ],
    "Aspect": "MemberTrim",
    "Warn": "The requested member may have been trimmed, please make sure that there's a reference to it",
    "Category": "KnownReflection"
  },
  {
    "Type": "System.Reflection.TypeInfo",
    "Methods": [
      "GetDeclaredNestedType"
    ],
    "Aspect": "TypeTrim",
    "Warn": "Add reference to the typ",
    "Category": "KnownReflection"
  },


  // System.Runtime.CompilerServices.RuntimeHelpers
  {
    "Type": "System.Runtime.CompilerServices.RuntimeHelpers",
    // Creates an instance of an object without calling its .ctor (leaves all fields initialized to zeroes).
    // Intended use case are de-serializers.
    // The problem is that linker will not see this as an instantiation attempt and will not mark all virtuals to be kept.
    "Methods": [ "GetUninitializedObject" ],
    "Aspect": "MemberTrim",
    "Warn": "The type may be missing some virtual methods if only used via this method",
    "Category": "KnownReflection"
  },
  {
    "Type": "System.Runtime.CompilerServices.RuntimeHelpers",
    // Explicitly runs .cctor on a type specified by a runtime type handle. Needs investigation, maybe the only way to really do this
    // is to reference the type from the code and thus linker will see the type (and thus mark its .cctor), but this needs verification.
    "Methods": [ "RunClassConstructor" ],
    "Aspect": "MemberTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },
  {
    "Type": "System.Runtime.CompilerServices.RuntimeHelpers",
    // Explicitly runs module constructor on a module. Needs investigation, mainly around how the caller can get
    // the module handle and if linker will see it correctly and keep the module ctor.
    "Methods": [ "RunModuleConstructor" ],
    "Aspect": "TypeTrim",
    "Warn": "TODO - investigate",
    "Category": "ToInvestigate"
  },

  // System.RuntimeTypeHandle
  // !!! TODO !!! - lot of really dangerous internal calls, this seems to be the base of lot of reflection operations
  // We need to annotate this correctly in order to validate that there are no places in CoreLib which we forgot.
  // Almost all methods are internal, so this won't leak outside of CoreLib
  {
    "Type": "System.RuntimeTypeHandle",
    "Methods": [
      "CreateCaInstance",
      "CreateInstance",
      "CreateInstanceForAnotherGenericParameter"
    ],
    "Aspect": "MemberTrim",
    "Warn": "Internal (should not leak outside of CoreLib) - These methods require the specified type to be instantiated.",
    "Category": "KnownReflection - Internal"
  },

  // !!! Same goes for
  // System.RuntimeFieldHanle
  // System.RuntimeMethodHandle

  // System.Runtime.Loader.AssemblyLoadContext
  {
    "Type": "System.Runtime.Loader.AssemblyLoadContext",
    // TODO: Investigate if these are dangerous - basically similar to Assembly.Load
    "Methods": [
      "GetAssemblyName",
      "Load",
      "LoadFromAssemblyName",
      "LoadFromAssemblyPath",
      "LoadFromNativeImagePath",
      "LoadUnmanagedDll",
      "LoadUnmanagedDllFromPath"
    ],
    "Aspect": "AssemblyTrim",
    "Warn": "Loading additional assemblies means bringing code which linker could not analyze.",
    "Category": "Reflection - AssemblyLoad"
  },


  // System.Resources.ResourceManager
  //
  // .ctor(System.Type)
  // The Type is actually only used for two things:
  // - Get the Assembly of the type - which is then used as a fallback for satellite resource loading
  // - Get the FullName/Namespace of the type to scope the search for resource strings in the satellite assembly
  // Neither is a problem for linker, so in this case we just need to make sure the linker 
  // 
  // .ctor(System.String,System.Reflection.Assembly)
  // The assembly is only used to lookup attributes and to load resources from
  // - Attribute lookup - only happens for hardcoded attribute sealed types, and so even if linker
  //   is trimming attributes (optional) it will keep this one as the ResourceManager
  //   has a hard reference to the attribute type it's looking for.
  // - Loading resources from - linker doesn't trim resources and even if it would
  //   not finding them would be intentional in that case.
  {
    "Type": "System.Resources.ResourceManager",
    "Methods": [
      ".ctor(System.String,System.String,System.Type)",
      ".ctor(System.String,System.Reflection.Assembly,System.Type)",
      "CreateFileBasedResourceManager"
    ],
    "Aspect": "TypeTrim",
    "Warn": "Custom resource set",
    "Category": "CustomResourceSet"
  },


  {
    "Type": "-",
    "Methods": [],
    "Aspect": "MemberTrim",
    "Warn": "",
    "Category": ""
  }
]
